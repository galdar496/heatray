//
//  physicallyBased.rlsl
//  Heatray
//
//  Implement a physically-based material for hard-surfaces.
//
//

#include "accumulator.rlsl"
#include "globalData.rlsl"
#include "microfacet.rlsl"
#include "sequence.rlsl"

varying vec3 normal;

#if defined(HAS_TEXTURES)
varying vec2 texCoord;
#endif // defined(HAS_TEXTURES)

#if defined(USE_TANGENT_SPACE)
varying vec3 tangent;
varying vec3 bitangent;
#endif // defined(USE_TANGENT_SPACE)

uniformblock Material {
    sampler2D baseColorTexture;
    sampler2D metallicRoughnessTexture;
    sampler2D emissiveTexture;
    sampler2D normalmap;
    sampler2D clearCoatTexture;
    sampler2D clearCoatRoughnessTexture;
    sampler2D clearCoatNormalmap;
    sampler2D multiscatterLUT;

    vec3 baseColor;
    vec3 emissiveColor;
    float metallic;
    float roughness;
    float specularF0;
    float roughnessAlpha;
    float clearCoat;
    float clearCoatRoughness;
    float clearCoatRoughnessAlpha;
};

void setup()
{
    rl_OutputRayCount[0] = 2; // One for direct lighting, one for indirect lighting.
}

void main()
{
    if (rl_FrontFacing == false) return;

    vec3 N = normalize(normal);
    vec3 clearCoatN = N;

#if defined(HAS_NORMALMAP)
    {
        mat3 normalTransform = mat3(normalize(tangent), normalize(bitangent), N);
        vec3 normalTS = texture2D(Material.normalmap, texCoord).xyz * 2.0 - 1.0;
        N = normalize(normalTransform * normalTS);
    }
#endif // defined(HAS_NORMALMAP)

#if defined(HAS_CLEARCOAT_NORMALMAP)
    {
        mat3 clearCoatNormalTransform = mat3(normalize(tangent), normalize(bitangent), clearCoatN);
        vec3 clearCoatNormalTS = texture2D(Material.clearCoatNormalmap, texCoord).xyz * 2.0 - 1.0;
        clearCoatN = normalize(clearCoatNormalTransform * clearCoatNormalTS);
    }
#endif // defined(HAS_CLEARCOAT_NORMALMAP)

    mat3 frame = orthonormalFrame(N);
    vec3 V = -rl_InRay.direction;
    float NdotV = saturate(dot(N, V));

    vec3 baseColor = Material.baseColor;
#if defined(HAS_BASE_COLOR_TEXTURE)
    baseColor *= texture2D(Material.baseColorTexture, texCoord).rgb;
#endif //  defined(HAS_BASE_COLOR_TEXTURE)

    float metallic = Material.metallic;
    float roughness = Material.roughness;
    float roughnessAlpha = Material.roughnessAlpha;
#if defined(HAS_METALLIC_ROUGHNESS_TEXTURE)
    vec2 metallicRoughness = texture2D(Material.metallicRoughnessTexture, texCoord).bg;
    metallic *= metallicRoughness.r;
    roughness *= metallicRoughness.g;
    roughnessAlpha = roughness * roughness;
#endif // defined(HAS_METALLIC_ROUGHNESS_TEXTURE)

    float clearCoat = Material.clearCoat;
    float clearCoatRoughness = Material.clearCoatRoughness;
    float clearCoatRoughnenessAlpha = Material.clearCoatRoughnessAlpha;
#if defined(HAS_CLEARCOAT_TEXTURE)
    clearCoat *= texture2D(Material.clearCoatTexture, texCoord).r;
#endif // defined(HAS_CLEARCOAT_TEXTURE)
#if defined(HAS_CLEARCOAT_ROUGHNESS_TEXTURE)
    clearCoatRoughness *= texture2D(Material.clearCoatRoughnessTexture, texCoord).r;
    clearCoatRoughnenessAlpha = clearCoatRoughness * clearCoatRoughness;
#endif // defined(HAS_CLEARCOAT_ROUGHNESS_TEXTURE)

    vec3 emissive = Material.emissiveColor;
#if defined(HAS_EMISSIVE_TEXTURE)
    emissive = texture2D(Material.emissiveTexture, texCoord).rgb;
#endif // defined(HAS_EMISSIVE_TEXTURE)

    // Handle debug visualizations (if applicable).
    if (Globals.enableVisualizer == 1) {
        if (Globals.showGeometricNormals == 1) {
            accumulate(vec4((normal + 1.0) * 0.5, 1.0));
        }
#if defined(HAS_TEXTURES)
        else if (Globals.showUVs == 1) {
            accumulate(vec4(texCoord, 0.0, 1.0));
        }
#endif // defined(HAS_TEXTURES)
#if defined(USE_TANGENT_SPACE)
        else if (Globals.showTangents == 1) {
            accumulate(vec4((tangent + 1.0) * 0.5, 1.0));
        } else if (Globals.showBitangents == 1) {
            accumulate(vec4((bitangent + 1.0) * 0.5, 1.0));
        }
#if defined(HAS_NORMALMAP)
        else if (Globals.showNormalmap == 1) {
            accumulate(vec4(texture2D(Material.normalmap, texCoord).xyz, 1.0));
        }
#endif // defined(HAS_NORMALMAP)
#endif // defined(USE_TANGENT_SPACE)
        else if (Globals.showFinalNormals == 1) {
            accumulate(vec4((N + 1.0) * 0.5, 1.0));
        } else if (Globals.showBaseColor == 1) {
            accumulate(vec4(baseColor, 1.0));
        } else if (Globals.showEmissive == 1) {
            accumulate(vec4(emissive, 1.0));
        } else if (Globals.showRoughness == 1) {
            accumulate(vec4(roughness, roughness, roughness, 1.0));
        } else if (Globals.showMetallic == 1) {
            accumulate(vec4(metallic, metallic, metallic, 1.0));
        } else if (Globals.showClearcoat == 1) {
            accumulate(vec4(clearCoat, clearCoat, clearCoat, 1.0));
        } else if (Globals.showClearcoatRoughness == 1) {
            accumulate(vec4(clearCoatRoughness, clearCoatRoughness, clearCoatRoughness, 1.0));
        } else if (Globals.showShader == 1) {
            accumulate(vec4(1.0, 0.0, 0.0, 1.0));
        }
#if defined(HAS_CLEARCOAT_NORMALMAP)
        else if (Globals.showClearcoatNormalmap == 1) {
            accumulate(vec4(texture2D(Material.clearCoatNormalmap, texCoord).xyz, 1.0));
        }
#endif // defined(HAS_CLEARCOAT_NORMALMAP)
        return;
    }

    performAccumulate(rl_InRay.weight * emissive);
    float clearCoatNdotV = saturate(dot(clearCoatN, V));

    // https://nicedoc.io/KhronosGroup/glTF/extensions/2.0/Khronos/KHR_materials_clearcoat/README.md#user-content-implementation
    // For clear coat, we assume a fixed F0 of 0.04 (polyurethane has an IOR of 1.5).
    float clearCoatF = F_Schlick(0.04, clearCoatNdotV);
    float clearCoatScale = clearCoatF * clearCoat;
    float clearCoatBottomLayerScale = 1.0 - clearCoatScale; // Scale to apply to the bottom layer's diffuse/specular.

    vec3 Cdiff = (baseColor * (1.0 - metallic)) * clearCoatBottomLayerScale;

    // This approximation comes from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
    //vec3 Cspec = (0.16 * square(Material.specularF0) * (1.0 - metallic) + baseColor * metallic) * clearCoatBottomLayerScale;

    // And this comes from the Disney BRDF explorer: https://github.com/wdas/brdf/blob/main/src/brdfs/disney.brdf#L104
    vec3 Cspec = mix(vec3(Material.specularF0), baseColor, vec3(metallic)) * clearCoatBottomLayerScale;

    // The probability that we select the diffuse BRDF to sample while rendering.
    float diffuseLuminance  = luminosity(Cdiff);
    float specularLuminance = luminosity(Cspec);
    float probabilityNormalization = 1.0 / greaterThanZero(diffuseLuminance + specularLuminance + clearCoatScale);
    float diffuseProbability = diffuseLuminance * probabilityNormalization;
    float specularProbability = specularLuminance * probabilityNormalization;
    float clearCoatProbability = clearCoatScale * probabilityNormalization;

    mat3 clearCoatFrame;
    if (clearCoatProbability > 0.0) {
        clearCoatFrame = orthonormalFrame(clearCoatN);
    }

    // First perform direct lighting.
    {
        vec2 rand = getSequenceValue(rl_InRay.sequenceID + rl_InRay.depth, Globals.sampleIndex + rl_InRay.sequenceIndexOffset);

        // Determine if we sample diffuse, specular, or clearcoat.
        // For direct lighting, we always use the next sequence for this probability.
        vec2 probability = getSequenceValue(rl_InRay.sequenceID + rl_InRay.depth + 1, Globals.sampleIndex + rl_InRay.sequenceIndexOffset);
        if (probability.x <= diffuseProbability) {
            directDiffuseSample(N, 
                                Cdiff,
                                diffuseProbability,
                                probability.y,
                                rand,
                                frame);
        } else if (probability.x <= (diffuseProbability + clearCoatProbability)) {
            directSpecularSample(clearCoatN, 
                                 V, 
                                 clearCoatNdotV,
                                 vec3(clearCoatScale),
                                 clearCoatRoughnenessAlpha,
                                 Material.multiscatterLUT,
                                 clearCoatRoughness,
                                 clearCoatProbability,
                                 probability.y,
                                 rand,
                                 frame);
        } else if (probability.x <= (diffuseProbability + clearCoatProbability + specularProbability)) {
            directSpecularSample(N, 
                                 V, 
                                 NdotV,
                                 Cspec,
                                 roughnessAlpha,
                                 Material.multiscatterLUT,
                                 roughness,
                                 specularProbability,
                                 probability.y,
                                 rand,
                                 frame);
        }
    }

    // Now sample the indirect lighting.
    if (rl_InRay.depth < Globals.maxRayDepth) {
        // Perform Russian Roulette.
        if (rl_InRay.depth > 3) {
            // For Russian Roulette, we always use 2 sequences away for random numbers.
            vec2 rand = getSequenceValue(rl_InRay.sequenceID + rl_InRay.depth + 2, Globals.sampleIndex + rl_InRay.sequenceIndexOffset);
            float probability = max(rl_InRay.weight.x, max(rl_InRay.weight.y, rl_InRay.weight.z));
            if (rand.x >= probability) {
                return; // This ray has been terminated.
            }

            rl_InRay.weight /= probability;
        }

        // For indirect lighting, we always use 3 sequences away for random numbers.
        vec2 rand = getSequenceValue(rl_InRay.sequenceID + rl_InRay.depth + 3, Globals.sampleIndex + rl_InRay.sequenceIndexOffset);

        // Determine if we sample diffuse or specular. We use 4 sequences away to determine this probability.
        vec2 probability = getSequenceValue(rl_InRay.sequenceID + rl_InRay.depth + 4, Globals.sampleIndex + rl_InRay.sequenceIndexOffset);
        if (probability.x <= diffuseProbability) {
            indirectDiffuseSample(N, 
                                  Cdiff,
                                  diffuseProbability,
                                  1.0,
                                  rand,
                                  frame,
                                  rl_NullPrimitive);
        } else if (probability.x <= (diffuseProbability + clearCoatProbability)) {
            indirectSpecularSample(clearCoatN,
                                   V,
                                   clearCoatNdotV,
                                   vec3(clearCoatScale),
                                   clearCoatRoughnenessAlpha,
                                   Material.multiscatterLUT,
                                   clearCoatRoughness,
                                   clearCoatProbability,
                                   1.0,
                                   rand,
                                   frame,
                                   rl_NullPrimitive);
        } else if (probability.x <= (diffuseProbability + clearCoatProbability + specularProbability)) {
            indirectSpecularSample(N,
                                   V,
                                   NdotV,
                                   Cspec,
                                   roughnessAlpha,
                                   Material.multiscatterLUT,
                                   roughness,
                                   specularProbability,
                                   1.0,
                                   rand,
                                   frame,
                                   rl_NullPrimitive);
        }
    }
}