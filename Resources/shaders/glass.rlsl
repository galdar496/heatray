//
//  glass.rlsl
//  Heatray
//
//  Implement a physically-based glass material for refractive surfaces.
//
//

#include "rayAttributes.rlsl"
#include "brdfs.rlsl"
#include "globalData.rlsl"
#include "lightSampling.rlsl"
#include "sequence.rlsl"

varying vec3 normal;

#if defined(HAS_TEXTURES)
varying vec2 texCoord;
#endif // defined(HAS_TEXTURES)

#if defined(USE_TANGENT_SPACE)
varying vec3 tangent;
varying vec3 bitangent;
#endif // defined(USE_TANGENT_SPACE)

#if defined(VERTEX_COLORS)
varying vec3 vertexColor;
#endif // defined(VERTEX_COLORS)

uniformblock Material {
    sampler2D baseColorTexture;
    sampler2D normalmap;
    sampler2D metallicRoughnessTexture;
    vec3 baseColor;
    float roughness;
    float roughnessAlpha;
    float ior;
    float density;
    float specularF0;
};

void setup()
{
    rl_OutputRayCount[0] = 2; // One for direct lighting, one for indirect lighting.
}

void indirectSpecularGlassSample(vec3 N, vec3 I, float NdotI, vec3 weight, vec3 baseColor, float roughnessAlpha, float optionalLightSampleProbability, vec2 rand, mat3 frame, primitive rayMissPrimitive)
{
    // Note that sampleVisibleGGX() is returning a microfacet normal. 
    // We still need to reflect about that normal to get our final sample direction.
    vec3 localSpaceI = transpose(frame) * I;
    vec3 H = frame * sampleVisibleGGX(localSpaceI, rand.x, rand.y, roughnessAlpha);
    float IdotH = saturate(dot(I, H));
    vec3 O = normalize(2.0 * IdotH * H - I);

    float NdotO = dot(N, O);
    if (NdotO > 0.0) {
        NdotO = saturate(NdotO);
        float NdotH = saturate(dot(N, H));

        // The PDF of our sample function is (D * NdotH) / (4 * VdotH).
        float G = G2_Smith_GGX(NdotO, NdotI, Material.roughnessAlpha);

        vec3 reflectance = baseColor * ((G * IdotH) / (NdotH * NdotI));
        reflectance *= weight;
        reflectance /= optionalLightSampleProbability;

        if (dot(reflectance, reflectance) > 1e-5) {
            createRay();
                rl_OutRay.direction         = O;
                rl_OutRay.weight            = reflectance;
                rl_OutRay.occlusionTest     = (rayMissPrimitive == rl_NullPrimitive) ? false : true;
                rl_OutRay.defaultPrimitive  = rayMissPrimitive;
            emitRay();
        }
    }
}

void directSpecularGlassSample(vec3 N, vec3 I, float NdotI, vec3 weight, vec3 baseColor, float roughnessAlpha, float lightProbability, vec2 rand, mat3 frame)
{
    // First we determine which light we are sampling via the light probability.
    vec3 lightDir;
    primitive lightPrimitive;
    float lightSampleProbability;
    float lightMaxDistance;
    int lightType;
    computeLightSample(N, lightProbability, lightDir, lightPrimitive, lightSampleProbability, lightMaxDistance, lightType);

    if (lightType != LIGHT_TYPE_ENVIRONMENT) {
        float NdotO = dot(N, lightDir);
        if (NdotO > 0.0) {
            NdotO = saturate(NdotO);
            vec3 H = normalize(I + lightDir);
            float NdotH = saturate(dot(N, H));
            float IdotH = saturate(dot(I, H));

            // Microfacet BRDF: (DFG) / (4*NdotL*NdotV)
            // However, F is cancelled out as it's part of the probability for determining
            // if we transmit or reflect.

            float D = D_GGX(NdotH, roughnessAlpha);
            float G = G2_Smith_GGX(NdotO, NdotI, roughnessAlpha);
        
            // Note that the NdotO cancels out here.
            float specular = (D * G) / greaterThanZero(4.0 * NdotI);

            vec3 reflectance = specular * baseColor;
            reflectance *= weight;
            reflectance /= lightSampleProbability;

            if (dot(reflectance, reflectance) > 1e-5) {
                createRay();
                    rl_OutRay.direction         = lightDir;
                    rl_OutRay.weight            = reflectance;
                    rl_OutRay.occlusionTest     = true;
                    rl_OutRay.defaultPrimitive  = lightPrimitive;
                    if (lightType == LIGHT_TYPE_POINT) {
                        rl_OutRay.maxT = lightMaxDistance;
                    }
                emitRay();
            }
        }
    } else if (lightSampleProbability > 0.0) {
        indirectSpecularGlassSample(N, I, NdotI, weight, baseColor, roughnessAlpha, lightSampleProbability, rand, frame, EnvironmentLight.lightPrimitive);
    }
}

vec3 beersLaw(vec3 baseColor)
{
    vec3 absorption = vec3(1.0) - baseColor;
    float rayLength = rl_IntersectionT;
    return rl_InRay.weight * exp(absorption * Material.density * -rayLength);
}

void main()
{
    vec3 N = normalize(normal);
    float nIn = 1.0; // air.
    float nOut = Material.ior;
    vec3 weight = rl_InRay.weight;

#if defined(HAS_NORMALMAP)
    {
        mat3 normalTransform = mat3(normalize(tangent), normalize(bitangent), N);
        vec3 normalTS = texture2D(Material.normalmap, texCoord).xyz * 2.0 - 1.0;
        N = normalize(normalTransform * normalTS);
    }
#endif // defined(HAS_NORMALMAP)

    vec3 baseColor = Material.baseColor;
#if defined(HAS_BASE_COLOR_TEXTURE)
    baseColor *= texture2D(Material.baseColorTexture, texCoord).rgb;
#endif //  defined(HAS_BASE_COLOR_TEXTURE)
#if defined(VERTEX_COLORS)
    baseColor *= vertexColor;
#endif // defined(VERTEX_COLORS)

    if (rl_FrontFacing == false) {
        // We're inside of the shape.
        N = -N;
        nIn = Material.ior;
        nOut = 1.0;
        weight = beersLaw(baseColor); // Account for absorption.
    }

    float roughness = Material.roughness;
    float roughnessAlpha = Material.roughnessAlpha;
#if defined(HAS_METALLIC_ROUGHNESS_TEXTURE)
    vec2 metallicRoughness = texture2D(Material.metallicRoughnessTexture, texCoord).bg;
    // Ignore metallic as this is a glass shader.
    roughness *= metallicRoughness.g;
    roughnessAlpha = roughness * roughness;
#endif // defined(HAS_METALLIC_ROUGHNESS_TEXTURE)

    // Handle debug visualizations (if applicable).
    if (Globals.enableVisualizer == 1) {
        if (Globals.showGeometricNormals == 1) {
            accumulate(vec4((normal + 1.0) * 0.5, 1.0));
        } else if (Globals.showFinalNormals == 1) {
            accumulate(vec4((N + 1.0) * 0.5, 1.0));
        } else if (Globals.showBaseColor == 1) {
            accumulate(vec4(baseColor, 1.0));
        } else if (Globals.showRoughness == 1) {
            accumulate(vec4(roughness, roughness, roughness, 1.0));
        } else if (Globals.showFinalNormals == 1) {
            accumulate(vec4((N + 1.0) * 0.5, 1.0));
        } else if (Globals.showShader == 1) {
            accumulate(vec4(0.0, 1.0, 0.0, 1.0));
        }
#if defined(HAS_TEXTURES)
        else if (Globals.showUVs == 1) {
            accumulate(vec4(texCoord, 0.0, 1.0));
        }
#endif // defined(HAS_TEXTURES)
#if defined(USE_TANGENT_SPACE)
        else if (Globals.showTangents == 1) {
            accumulate(vec4((tangent + 1.0) * 0.5, 1.0));
        } else if (Globals.showBitangents == 1) {
            accumulate(vec4((bitangent + 1.0) * 0.5, 1.0));
        }
#if defined(HAS_NORMALMAP)
        else if (Globals.showNormalmap == 1) {
            accumulate(vec4(texture2D(Material.normalmap, texCoord).xyz, 1.0));
        }
#endif // defined(HAS_NORMALMAP)
#endif // defined(USE_TANGENT_SPACE)
        return;
    }

    mat3 frame = orthonormalFrame(N);
    vec3 I = -rl_InRay.direction;
    float eta = nIn / nOut;

    vec3 localSpaceI = transpose(frame) * I;
    vec2 rand = getSequenceValue(rl_InRay.sequenceID + rl_InRay.depth, Globals.sampleIndex + rl_InRay.sequenceIndexOffset);
    vec3 H = frame * sampleVisibleGGX(localSpaceI, rand.x, rand.y, roughnessAlpha);
    float HdotI = saturate(dot(H, I));

    vec2 refractProbability = getSequenceValue(rl_InRay.sequenceID + rl_InRay.depth + 1, Globals.sampleIndex + rl_InRay.sequenceIndexOffset);
    float F = F_Fresnel(eta, HdotI);

    float NdotI = saturate(dot(N, I));

    if (!rl_FrontFacing) {
        // If we're internal to an object then the only option for us is to refract. Therefore, we 
        // force the probability here.
        refractProbability = vec2(refractProbability.x, 0.0);
    }

    // Note that since the Fresnel term is used to determine how to sample it ends up getting cancelled out of the following math.
    if (refractProbability.y < (1.0 - F)) {
        vec3 O = normalize(refract(-I, H, eta));

        // Note that these are purposely not clamped as the BSDF considers the entire sphere as opposed to a hemisphere.
        float NdotO = abs(dot(N, O));

        float G2 = G2_Smith_GGX(NdotI, NdotO, roughnessAlpha);
        float G1 = G1_Smith_GGX(NdotI, roughnessAlpha);

        // https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf
        // And for the PDF: https://hal.inria.fr/hal-00996995v1/document
        vec3 transmission = baseColor * G2 / greaterThanZero(G1);

        transmission *= weight;
        if (dot(transmission, transmission) > 1e-5 && rl_InRay.depth < Globals.maxRayDepth) {
            createRay();
                rl_OutRay.direction = O;
                rl_OutRay.weight = transmission;
                rl_OutRay.occlusionTest = false;
                rl_OutRay.defaultPrimitive = EnvironmentLight.lightPrimitive;
            emitRay();
        }
    } else {
        // Do reflection. Use unique microfacets for the direct and indirect lighting.
        {
            rand = getSequenceValue(rl_InRay.sequenceID + rl_InRay.depth + 2, Globals.sampleIndex + rl_InRay.sequenceIndexOffset);
            directSpecularGlassSample(N, I, NdotI, weight, baseColor, roughnessAlpha, refractProbability.x, rand, frame);
        }
        if (rl_InRay.depth < Globals.maxRayDepth) {
            // Perform Russian Roulette.
            if (rl_InRay.depth > 3) {
                // For Russian Roulette, we always use 3 sequences away for random numbers.
                vec2 rand = getSequenceValue(rl_InRay.sequenceID + rl_InRay.depth + 3, Globals.sampleIndex + rl_InRay.sequenceIndexOffset);
                float probability = max(weight.x, max(weight.y, weight.z));
                if (rand.x >= probability) {
                    return; // This ray has been terminated.
                }

                weight /= probability;
            }

            rand = getSequenceValue(rl_InRay.sequenceID + rl_InRay.depth + 4, Globals.sampleIndex + rl_InRay.sequenceIndexOffset);
            indirectSpecularGlassSample(N, I, NdotI, weight, baseColor, roughnessAlpha, 1.0, rand, frame, rl_NullPrimitive);
        }
    }
}
