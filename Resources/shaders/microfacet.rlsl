//
//  microfacet.rlsl
//  Heatray
//
//  Perform sampling of various components following microfacet theory BSDFs (diffuse, specular, transmissive).
//
//

#include "brdfs.rlsl"
#include "globalData.rlsl"
#include "sequence.rlsl"
#include "rayAttributes.rlsl"
#include "utility.rlsl"

// Note that this is not the alpha roughness, but the material roughness.
vec3 computeMultiscattering(sampler2D multiscatterLUT, vec3 Cspec, float NdotI, float roughness)
{
	// https://blog.selfshadow.com/publications/turquin/ms_comp_final.pdf
	float msLUTvalue = texture2D(multiscatterLUT, vec2(NdotI, roughness)).r;
	vec3 f_ms = 1.0 + Cspec * ((1.0 - msLUTvalue) / msLUTvalue);
	return f_ms;
}

void sampleDiffuse(vec3 N, vec3 I, float NdotI, mat3 frame, vec2 rand, 
				   vec3 Cdiff, vec3 Cspec, float roughnessAlpha,
				   float sampleProbability, bool isDirectLightingSample, primitive rayMissPrimitive)
{
	// Get a random direction on the cosine lobe.
	vec3 dir = cosineWeightedSample(rand.x, rand.y);
	vec3 O = frame * dir;
	
	float NdotO = dot(N, O);
	if (NdotO > 0.0) {
		NdotO = saturate(NdotO);
		// Note that the PDF of cosine-weighted sampling is cos(theta)/pi but cancels out.
		vec3 diffuse = Cdiff;

		vec3 reflectance = diffuse;
		reflectance /= sampleProbability;

		reflectance *= rl_InRay.weight;
		if (dot(reflectance, reflectance) > 1e-5) {
			createRay();
				rl_OutRay.direction = O;
				rl_OutRay.weight = reflectance;
				rl_OutRay.occlusionTest = isDirectLightingSample;
				rl_OutRay.defaultPrimitive = rayMissPrimitive;
			emitRay();
		}
	}
}

void sampleSpecular(vec3 N, vec3 I, float NdotI, mat3 frame, vec2 rand, 
				    vec3 Cspec, float roughnessAlpha,
				    float sampleProbability, bool isDirectLightingSample, primitive rayMissPrimitive,
					sampler2D multiscatterLUT, float roughness)
{
	// Note that sampleGGX() is returning a microfacet normal. 
	// We still need to reflect about that normal to get our final sample direction.
	vec3 H = frame * sampleGGX(rand.x, rand.y, roughnessAlpha);
	float IdotH = dot(I, H);
	vec3 O = normalize(2.0 * IdotH * H - I);

	float NdotO = dot(N, O);
	if (NdotO > 0.0) {
		IdotH = saturate(IdotH);
		NdotO = saturate(NdotO);
		float NdotH = saturate(dot(N, H));

		// The PDF of our sample function is (D * NdotH) / (4 * VdotH).
		float G = G2_Smith_GGX(NdotO, NdotI, roughnessAlpha);
		vec3  F = F_Schlick(Cspec, IdotH);
		vec3 specular = (F * G * IdotH) / (NdotH * NdotI);

		// Account for multiscattering.
		specular *= computeMultiscattering(multiscatterLUT, Cspec, NdotI, roughness);

		vec3 reflectance = specular;
		reflectance /= sampleProbability;
		reflectance *= rl_InRay.weight;

		if (dot(reflectance, reflectance) > 1e-5) {
			createRay();
				rl_OutRay.direction = O;
				rl_OutRay.weight = reflectance;
				rl_OutRay.occlusionTest = isDirectLightingSample;
				rl_OutRay.defaultPrimitive = rayMissPrimitive;
			emitRay();
		}
	}
}
